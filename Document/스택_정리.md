# RentalWeb 기술 스택 정리

이 문서는 RentalWeb 프로젝트의 기술 스택 선정 과정과 최종 결정을 기록합니다.

## 1. 최종 결정 스택 요약

*   **프론트엔드:** **React** (개발) + **Vercel** (배포)
*   **백엔드:** **NestJS** (개발) + **Railway** (배포)
*   **데이터베이스:** **Supabase** (PostgreSQL 호스팅)

**한 문장 요약:** Supabase에서 제공하는 DB를 사용하고, NestJS로 만든 서버를 Railway에, React로 만든 화면을 Vercel에 배포한다.

---

## 2. 스택 상세 비교 및 선정 이유

### 2.1. 데이터베이스 (PostgreSQL)

| 구분 | 🥇 Supabase (선택) | 🥈 Neon | 🥉 AWS RDS |
| :--- | :--- | :--- | :--- |
| **개요** | 올인원 개발 플랫폼. DB 외 부가기능이 강력함. | 차세대 서버리스 PostgreSQL. DB 자체 성능에 집중. | 클라우드 DB의 표준. 가장 강력하지만 복잡함. |
| **장점** | - 압도적인 편의성 (UI/UX)<br>- 인증, 스토리지 등 통합 제공<br>- 넉넉한 무료 플랜 | - 사용 안 할 때 비용 0에 수렴<br>- DB 브랜칭 기능<br>- 넉넉한 무료 플랜 | - 최고의 안정성 및 성능<br>- 매우 세밀한 설정 가능<br>- 다른 AWS 서비스와 완벽 연동 |
| **단점** | - DB 외의 기능에 종속될 수 있음 | - UI가 개발자 중심적<br>- 부가기능은 직접 구현 | - 매우 복잡한 초기 설정<br>- 비용 예측이 어렵고 비쌈<br>- 작은 프로젝트에는 과함 |

**✅ 선정 이유:** 압도적인 편의성, 훌륭한 관리 UI, 넉넉한 무료 플랜을 제공하여 초기 개발 단계에 가장 적합합니다.

### 2.2. 프론트엔드 호스팅

| 구분 | 🥇 Vercel (선택) | 🥈 Netlify | 🥉 Cloudflare Pages |
| :--- | :--- | :--- | :--- |
| **개요** | 모던 프론트엔드 배포의 표준. | Vercel의 강력한 라이벌. | 글로벌 네트워크 최강자. |
| **장점** | - 최고의 개발 경험 (DX)<br>- Git Push 시 자동 배포/미리보기<br>- 프레임워크 자동 인식 및 최적화 | - Vercel과 거의 동일한 장점<br>- 자체 부가기능(Forms 등) 제공<br>- 성숙하고 안정적인 플랫폼 | - 가장 넉넉한 무료 플랜 (트래픽 무제한)<br>- Cloudflare의 CDN 성능<br>- 다른 Cloudflare 서비스와 연동 용이 |
| **단점** | - 무료 빌드 시간에 제한 있음 | - 신규 프레임워크 지원이 살짝 늦을 수 있음 | - 무료 빌드 시간에 제한 있음 |

**✅ 선정 이유:** 최고의 개발 경험(DX)과 매끄러운 Git 자동 배포 워크플로우를 제공하여 개발 생산성을 극대화합니다. 초기 단계에서는 Vercel로 시작하여 개발 속도를 높이는 것이 유리합니다.

### 2.3. 백엔드 호스팅

| 구분 | 🥇 Railway (선택) | 🥈 Heroku | 🥉 Fly.io |
| :--- | :--- | :--- | :--- |
| **개요** | 차세대 PaaS. Heroku의 단점을 개선. | PaaS의 원조. 시장의 표준이었던 서비스. | 사용자와 가까운 곳에 서버를 배포하는 데 특화. |
| **장점** | - 매우 쉬운 사용법 (UI/UX)<br>- Git Push 시 자동 배포<br>- 사용량 기반의 합리적 요금제 | - 매우 성숙하고 안정적임<br>- 방대한 문서와 커뮤니티<br>- 다양한 부가기능(Add-on) 생태계 | - 뛰어난 글로벌 성능<br>- 넉넉한 무료 플랜<br>- Docker 기반으로 유연한 환경 구성 |
| **단점** | - Heroku만큼 부가기능이 많지는 않음 | - 무료 플랜이 거의 사라짐<br>- UI/UX가 다소 낡았음 | - Docker에 대한 이해가 필요함<br>- Railway보다 초기 설정이 복잡함 |

**✅ 선정 이유:** Heroku의 편리함은 유지하면서 더 합리적인 요금제를 제공하는 차세대 PaaS로, NestJS 서버를 배포하기에 가장 간편하고 효율적입니다.

---

## 3. 추가 고려 스택 (개발 효율성 및 품질 향상)

### 3.1. 백엔드 DB 연동: ORM (Object-Relational Mapping)

*   **문제점:** 순수 SQL 쿼리 작성의 번거로움, 실수 가능성, 보안 취약성.
*   **해결책:** **Prisma** (추천) 또는 **TypeORM**.
*   **도입 시점:** **즉시.** 백엔드 개발의 가장 기초가 되는 부분이므로, 프로젝트 시작과 함께 결정해야 합니다.
*   **추천 이유 (Prisma):** 뛰어난 타입 안정성과 직관적인 API로 생산성을 높여줍니다.

### 3.2. 프론트엔드 API 데이터 통신: 서버 상태 관리

*   **문제점:** React에서 백엔드 API로 데이터를 요청하고, 로딩/에러 상태 관리, 캐싱 등 반복적이고 복잡한 작업.
*   **해결책:** **React Query (TanStack Query)**
*   **도입 시점:** 프론트엔드에서 백엔드 API를 처음 호출할 때.

### 3.3. 프론트엔드 전역 상태 관리

*   **문제점:** 여러 페이지/컴포넌트에서 공통으로 사용하는 데이터(로그인 정보, 장바구니 등) 관리의 복잡성.
*   **해결책:** **Zustand** (추천) 또는 **Recoil**.
*   **도입 시점:** 공통으로 관리할 전역 데이터가 생겼을 때.

### 3.4. 코드 품질 및 자동화 (CI/CD)

*   **문제점:** 일관성 없는 코드 스타일, 신규 코드에 의한 기존 기능 고장 방지.
*   **해결책:** **ESLint** (코드 검사), **Prettier** (자동 포맷팅), **GitHub Actions** (자동 테스트/빌드).
*   **도입 시점:** 프로젝트 시작부터 점진적으로 도입.

---

## 4. 그 외 논의된 기술

### 4.1. Message Queue (MQ)

*   **개념:** 서비스 간의 작업을 '주문서'처럼 전달하여 비동기로 처리하게 하는 기술 (예: RabbitMQ, Kafka).
*   **필요성:** 현재 프로젝트 규모에서는 불필요. 서비스가 매우 커져 SMS 대량 발송, 무거운 파일 처리 등 백그라운드 작업이 많아지면 도입을 고려할 수 있습니다.

### 4.2. Docker

*   **개념:** 애플리케이션을 실행 환경과 함께 '컨테이너'로 패키징하여 어디서든 동일하게 실행되도록 하는 기술.
*   **필요성:** Railway, Fly.io 같은 최신 배포 서비스들이 내부적으로 Docker를 사용하므로, 개발자가 직접 Docker를 다루지 않아도 그 이점을 누릴 수 있습니다. 따라서 당장 직접 사용할 필요는 없습니다.
