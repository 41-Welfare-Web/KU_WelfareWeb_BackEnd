# RentalWeb 기술 스택 정리

이 문서는 RentalWeb 프로젝트의 기술 스택 선정 과정과 최종 결정을 기록합니다.

## 1. 최종 결정 스택 요약

*   **프론트엔드:** **React** (배포: **Vercel**)
*   **백엔드:** **NestJS** + **Prisma (ORM)** (배포: **Railway**)
*   **데이터베이스:** **Supabase (PostgreSQL)**

**한 문장 요약:** Supabase DB를 사용하고, NestJS API 서버를 Railway에, React 프론트엔드를 Vercel에 배포하여 운영한다.

---

## 2. 스택 상세 선정 이유

### 2.1. 데이터베이스: Supabase (PostgreSQL)
*   **이유:** PostgreSQL을 별도 서버 설치 없이 즉시 사용할 수 있으며, 관리 UI가 매우 직관적입니다. 추후 스토리지나 실시간 기능이 필요할 때 확장하기 용이합니다.

### 2.2. 백엔드: NestJS + Prisma (ORM)
*   **이유:** 프로젝트의 복잡한 비즈니스 로직(예약 재고 검증, 운영일 계산 등)을 처리하기 위해 구조화된 프레임워크인 NestJS가 적합합니다. Prisma를 통해 DB 타입을 안전하게 관리합니다.
*   **인증:** JWT 기반의 자체 인증 시스템을 구축하여 보안과 유연성을 확보합니다.

### 2.3. 프론트엔드: React
*   **이유:** 프론트엔드 개발팀의 주력 기술 스택을 따릅니다.

### 2.4. 인프라: Vercel & Railway
*   **이유:** 두 서비스 모두 Git 연동 배포(CD)가 매우 강력하여 개발자가 인프라 설정에 들이는 시간을 최소화하고 코드 작성에 집중할 수 있게 해줍니다.

---

## 3. 추가 고려 스택 (개발 효율성 및 품질 향상)

### 3.1. 백엔드 DB 연동: ORM (Object-Relational Mapping)

*   **문제점:** 순수 SQL 쿼리 작성의 번거로움, 실수 가능성, 보안 취약성.
*   **해결책:** **Prisma** (추천) 또는 **TypeORM**.
*   **도입 시점:** **즉시.** 백엔드 개발의 가장 기초가 되는 부분이므로, 프로젝트 시작과 함께 결정해야 합니다.
*   **추천 이유 (Prisma):** 뛰어난 타입 안정성과 직관적인 API로 생산성을 높여줍니다.

### 3.2. 프론트엔드 API 데이터 통신: 서버 상태 관리

*   **문제점:** React에서 백엔드 API로 데이터를 요청하고, 로딩/에러 상태 관리, 캐싱 등 반복적이고 복잡한 작업.
*   **해결책:** **React Query (TanStack Query)**
*   **도입 시점:** 프론트엔드에서 백엔드 API를 처음 호출할 때.

### 3.3. 프론트엔드 전역 상태 관리

*   **문제점:** 여러 페이지/컴포넌트에서 공통으로 사용하는 데이터(로그인 정보, 장바구니 등) 관리의 복잡성.
*   **해결책:** **Zustand** (추천) 또는 **Recoil**.
*   **도입 시점:** 공통으로 관리할 전역 데이터가 생겼을 때.

### 3.4. 코드 품질 및 자동화 (CI/CD)

*   **문제점:** 일관성 없는 코드 스타일, 신규 코드에 의한 기존 기능 고장 방지.
*   **해결책:** **ESLint** (코드 검사), **Prettier** (자동 포맷팅), **GitHub Actions** (자동 테스트/빌드).
*   **도입 시점:** 프로젝트 시작부터 점진적으로 도입.

---

## 4. 그 외 논의된 기술

### 4.1. Message Queue (MQ)

*   **개념:** 서비스 간의 작업을 '주문서'처럼 전달하여 비동기로 처리하게 하는 기술 (예: RabbitMQ, Kafka).
*   **필요성:** 현재 프로젝트 규모에서는 불필요. 서비스가 매우 커져 SMS 대량 발송, 무거운 파일 처리 등 백그라운드 작업이 많아지면 도입을 고려할 수 있습니다.

### 4.2. Docker

*   **개념:** 애플리케이션을 실행 환경과 함께 '컨테이너'로 패키징하여 어디서든 동일하게 실행되도록 하는 기술.
*   **필요성:** Railway, Fly.io 같은 최신 배포 서비스들이 내부적으로 Docker를 사용하므로, 개발자가 직접 Docker를 다루지 않아도 그 이점을 누릴 수 있습니다. 따라서 당장 직접 사용할 필요는 없습니다.
